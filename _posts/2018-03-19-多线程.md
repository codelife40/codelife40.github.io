---
layout: post
title:  "多线程"
date:   2018-03-14 16:30:57 +0800
categories: Java基础篇
tags: [多线程]
---

# 多线程

为什么要线程池？

- 创建对象和销毁对象是非常消耗资源的。所以如果并发的线程数量很多，每个线程都是执行很短的时间就结束了，这样频繁的创建和销毁会大大降低系统效率。所以为了提高程序性能，所以就需要尽可能的重用已有对象，创建线程池就是其中很好的解决方案。

使用线程池有以下几个优点：

- 重用线程池中的线程，较少因对象创建、销毁所带来的性能开销
- 能有效的控制线程的最大并发数，提高系统资源利用率，同时避免过多的资源竞争，避免堵塞。
- 能够多线程进行简单的管理，使线程的使用简单、高效。

Java中的线程池是通过Executor框架实现的。

Executors:提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口

### ThreadPoolExecutor类
ThreadPoolExecutor是线程池的具体实现类，一般用的各种线程池都是基于这个类实现的。这个是线程池中最核心的类。

ThreadPoolExecutor实现了AbstractExecutorService抽象类。
AbstractExecutorService类实现了ExecutorService接口。
ExecutorService又是继承了Executor接口。

public interface Executor {
	void executor(Runnable command);
}

Executor是顶级接口，只实现一个方法，通过这个方法可以想线程池提交一个任务，交由线程池去执行。

构造方法中的几个核心参数：

- corePoolSize：核心池的大小。当创建的线程数超过corePoolSize后，会放到阻塞队列中，当阻塞队列放满后，会继续创建线程，直到线程数等于maximumPoolSize。
- maximumPoolSize：线程池的最大线程数，决定了线程池中最大能创建多少个线程。超出这个值就会抛出异常。
- keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程数不大于corePoolSize。如果线程数>corePoolSize时，如果一个线程的空闲时间达到了keepAliveTime，就会终止。
- unit：参数keepAliveTime的时间单位。（天、小时、分钟、秒、毫秒、微妙、纳秒）
- workQueue：一个阻塞队列，用来存储等待执行的任务。这个参数也很重要，对线程池的运行过程产生重大影响。
	- ArrayBlockingQueue(少用)
	- LinkedBlockingQueue(常用)
	- SynchronousQueue(常用)
- threadFactory：线程工厂，主要用来创建线程
- handler：表示当拒绝处理任务时的策略

注意点：

- 默认情况下，创建好线程池后，线程池中的线程数为0，当有任务来了之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把达到的任务放到缓存队列当中。

### 线程池的原理

#### 1. 线程池的状态
volatile int runState 当前线程池的状态。用volatile变量来保证线程之间的可见性。

- RUNNING：创建线程池后，初始化时，线程池处于Running状态
- SHUTDOWN：调用了shutdown()方法后。此时线程不能够接受新的任务，它会等待所有任务执行完毕。
- STOP：调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且去尝试终止正在进行的任务。
- TERMINATED：当线程池处于shutdown或者stop状态，并且所有工作线程已经销毁，任务缓存队列已经清空或者执行结束后，线程池被设置为terminated状态

#### 2. 任务的执行

在Java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池。
Executors.newCachedThreadPool(); //创建一个缓冲池
Executors.newSingleThreadExecutor();//创建容量为1的缓冲池
Executors.newFixedThreadPool(int);//创建固定容量大小的缓冲池

## ThreadLocal
在多线程环境下，不同的线程会同时访问同一个共享变量。
ThreadLocal为了解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。

ThreadLocal实际上是Thread的一个局部变量。它为每个使用该变量的线程提供了独立的变量副本，所以每个线程都可以独立的改变自己的副本，而不会影响其他线程所对应副本






