---
layout: post
title:  "JVM内存回收机制"
date:   2018-03-14 16:30:57 +0800
categories: Java基础篇
tags: [JVM]
---

# GC

## 一、概念

JVM内存运行时数据区的三个重要地方：

- 堆（heap）：最大的一块区域，用于存放对象实例和数组，是全局共享的。
- 栈（stack）：虚拟机栈，主要存储基本数据类型，以及对象的引用，私有线程。
- 方法区（Method Area）：在class被加载后的一些信息，如常量、静态常量这些被放在这里，在Hotspot里面我们将它称为永生代。

用一张图来对内存运行时的数据区有一个大概的概况：
![](media/15210193192594/15210197241976.jpg)

### 二、堆（heap）
堆是JVM内存运行数据区中最重要的一块区域。这里也称为逻辑堆。主要用来存放对象实例和数组。对于所有的线程来说它是共享的。

对于Heap堆区是动态分配内存的，所以空间大小和生命周期都不是明确的。

GC的主要作用就是自动释放逻辑堆里实例对象所占用的内存。

逻辑堆中分成新生代和老年代，用来区分对象的存活时间，

堆又分成两个不同的区域：

- 新生代（Young）
	- 新生代又分为 Eden，From Survivor、To Survivor 三个区域。这样划分是为了使JVM能够更好的管理堆内存中的对象，包括内存的分配以及回收。 
- 老年代（Old）

堆大小 = 新生代+老年代
堆的大小可以通过参数-Xms、-Xmx来指定

JVM每次只会使用Eden和其中的一块Survivor区域来为对象服务，所以无论什么时候，总是有一块Survivor区域是空闲着的。

默认情况下，Eden：from：to = 8：1：1，因为总有一块Survivor区域是空闲的，所以新生代实际可用的内存空间为90%的新生代空间。

堆是GC收集垃圾的主要区域，GC分为 Minor GC、FullGC
Minor GC是发生在新生代中的垃圾收集动作，所采用的是复制算法。

新生代几乎是所有Java对象出生的地方，即Java对象申请的内存以及存放都是在这个地方。Java中大部分对象通常不需长久存活，具有朝生夕灭的性质。

 当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，
即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。
   但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。

### 三、方法区（Method Area）
方法区主要存储ClassLoader加载的类信息。可以理解成是已经编译好的代码存储区，所以存储包括类的元数据、常量池、字段，静态变量与方法内的局部变量以及编译好的字节码。

### 栈（stack）
在每个对象被创建的时候，在堆栈区都有一个对他的引用。比如：
Object obj = new Object();
Object在堆中申请了一个内容，new Object()创建了一个对象的实例存储在逻辑堆中，然后通过=号创建引用，这个引用存储在栈中。

pc寄存器（PC Regesiter）：在多线程中，系统需要给每个线程分配一个进程编号，这个时候才会需要寄存器。


### GC
GC分两种：

- Minor GC发生在新生代中的垃圾收集动作，所采用的是**复制算法**
- FullGC发生在老年代的垃圾收集动作，所采用的是**标记-清除算法**
	- FullGC发生的次数不会有Minor GC那么频繁，并且做一次Full GC要比一次Minor GC的时间更长。
	- 标记-清除收集垃圾的时候会产生需要内存碎片（即不连续的内存空间），此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次GC的收集动作。
	
![](media/15210193192594/15210393054137.jpg)



