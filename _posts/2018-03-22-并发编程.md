---
layout: post
title:  "并发编程"
date:   2018-03-22 16:30:57 +0800
categories: Java基础篇
tags: [并发编程]
---



## 并发编程

三大概念



### 一、原子性

即一个操作或多个操作要么全部执行成功，中间不会中断。要么就全部失败。

一个经典的银行转账的例子：

比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。

必须全部成功或者全部失败。

java中可以用synchronized和Lock来保证原子性。

### 二、可见性

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

对于可见性，Java提供了**volatile**关键字来保证可见性。

当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

Java的内存模型：

Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

简单点说就是，每个线程工作过程中用的变量先保存再自己的线程工作内存中，然后再写入主内存。如果期望线程对变量变更之后立刻生效，可以使用volatile关键词申明变量。volatile申明的变量来保证该变量的值有任何变更的时候，立刻会更新到主内存中。

另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

### 三、有序性

有序性是指程序是按代码的执行顺序进行。

指令重排：



指令重排不会影响单线程执行结果，但是会影响多线程下的结果。

volatile申明变量来保证变量的可见性，用**该关键词申明过的变量是不允许指令重排的**

volatile可以保证可见性，但是不能保证原子性。

变量的自增操作是不具备原子性的，它其实包含了三个步骤，1获取原始值，2在原始值上+1，3写入工作内存。int类型的变量是不具备原子性的。**可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。**

#### volatile的应用场景：

synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：

1）对变量的写操作不依赖于当前值

2）该变量没有包含在具有其他变量的不变式中



参考文章：

http://www.importnew.com/24082.html